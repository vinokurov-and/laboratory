# Загрузка данных с API в React: мокирование запросов и тестирование

## Общая схема выполнения

1. **Реализуйте React-компонент** `UserTable.tsx` с загрузкой данных и отображением таблицы.
2. **Подключите компонент** в `App.tsx`.
3. **Напишите тесты** с мокированием `fetch` с помощью Jest.
4. **Проверьте** прохождение тестов локально и на GitHub.
5. **Выполните доработку по варианту**, который зависит от первой буквы вашей фамилии.

---

## Часть 1. Компонент `UserTable.tsx`

**Файл:** `src/components/UserTable.tsx`

**Требования:**

- Кнопка «Загрузить пользователей».
- При клике: запрос к `https://jsonplaceholder.typicode.com/users`.
- Таблица с колонками: **Имя**, **Email**, **Телефон**, **Сайт**.
- Состояния:
  - Во время запроса показывать «Загрузка…».
  - При ошибке выводить «Ошибка при загрузке».
  - При данных — таблицу с пользователями.

```typescript
import { useState } from 'react'

type User = {
  id: number
  name: string
  email: string
  phone: string
  website: string
}

export default function UserTable() {
  const [users, setUsers] = useState<User[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const fetchUsers = async () => {
    setLoading(true)
    setError(null)
    try {
      const response = await fetch('https://jsonplaceholder.typicode.com/users')
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      const data: User[] = await response.json()
      setUsers(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Неизвестная ошибка')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="user-table-container">
      <button onClick={fetchUsers} disabled={loading}>
        {loading ? 'Загрузка...' : 'Загрузить пользователей'}
      </button>

      {error && <p style={{ color: 'red' }}>{error}</p>}

      {users.length > 0 && (
        <table
          border={1}
          style={{ marginTop: '20px', borderCollapse: 'collapse', width: '100%' }}
        >
          <thead>
            <tr>
              <th>Имя</th>
              <th>Email</th>
              <th>Телефон</th>
              <th>Сайт</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr key={user.id}>
                <td>{user.name}</td>
                <td>{user.email}</td>
                <td>{user.phone}</td>
                <td>
                  <a href={`http://${user.website}`} target="_blank" rel="noopener noreferrer">
                    {user.website}
                  </a>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  )
}
```

---

## Часть 2. Подключение `UserTable` в `App.tsx`

**Файл:** `src/App.tsx`

Добавьте компонент `UserTable` к уже существующей разметке.

```typescript
import UserTable from './components/UserTable'
import './App.css'

function App() {
  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank" rel="noreferrer">
          <img src="/vite.svg" className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank" rel="noreferrer">
          <img src="/react.svg" className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <Counter />
      <UserTable />
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App
```

---

## Часть 3. Тесты для `UserTable`

**Файл:** `src/components/UserTable.test.tsx`

Напишите тесты с использованием `@testing-library/react` и мокированием `fetch`.

```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import UserTable from './UserTable'

declare global {
  // eslint-disable-next-line no-var
  var fetch: jest.Mock
}

global.fetch = jest.fn()

describe('UserTable', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  test('renders button and does not show table initially', () => {
    render(<UserTable />)
    expect(screen.getByText(/загрузить пользователей/i)).toBeInTheDocument()
    expect(screen.queryByText(/иван/i)).not.toBeInTheDocument()
  })

  test('loads users and displays them when button is clicked', async () => {
    const mockUsers = [
      {
        id: 1,
        name: 'Иван Иванов',
        email: 'ivan@example.com',
        phone: '+7 (999) 123-45-67',
        website: 'example.com',
      },
    ]

    global.fetch.mockResolvedValue({
      ok: true,
      json: async () => mockUsers,
    })

    render(<UserTable />)
    fireEvent.click(screen.getByText(/загрузить пользователей/i))

    expect(await screen.findByText(/иван иванов/i)).toBeInTheDocument()
    expect(screen.getByText(/ivan@example.com/i)).toBeInTheDocument()
  })

  test('shows error when fetch fails', async () => {
    global.fetch.mockRejectedValue(new Error('Network error'))

    render(<UserTable />)
    fireEvent.click(screen.getByText(/загрузить пользователей/i))

    expect(await screen.findByText(/ошибка при загрузке/i)).toBeInTheDocument()
  })
})
```

---

## Часть 4. Проверка

1. **Локально:** запустите тесты (например, `npm test` или `npm run test`) и убедитесь, что все проверки проходят.
2. **CI/CD:** убедитесь, что тесты успешно выполняются на GitHub.

---

## Часть 5. Индивидуальные доработки по вариантам

Определите вариант по первой букве вашей фамилии (кириллица).

| Диапазон букв | Вариант |
|---------------|---------|
| А, Б, В, Г    | Вариант 1 |
| Д, Е, Ё, Ж, З | Вариант 2 |
| И, Й, К, Л    | Вариант 3 |
| М, Н, О, П    | Вариант 4 |
| Р, С, Т, У, Ф | Вариант 5 |
| Х, Ц, Ч, Ш    | Вариант 6 |
| Щ, Э, Ю, Я    | Вариант 7 |

### Вариант 1. Работа с комментариями
- Измените endpoint на `https://jsonplaceholder.typicode.com/comments`.
- В таблице отображайте колонки **Имя (name)**, **Email**, **Тело комментария (body)**.
- Тело комментария обрезайте до 50 символов, добавляйте `...` при необходимости.
- Пример:

```jsx
<td>{user.body.length > 50 ? `${user.body.slice(0, 50)}...` : user.body}</td>
```

### Вариант 2. Фильтрация по городу
- Добавьте `<select>` со значениями **Moscow**, **Kulm**, **London**.
- Фильтрация по выбранному городу (`user.address.city`).
- Добавьте кнопку «Сбросить фильтр».
- Напишите дополнительный тест на проверку фильтрации.

### Вариант 3. Сортировка по имени
- Заголовок колонки **Имя** сделайте кликабельным.
- Первый клик: сортировка от А к Я, второй — от Я к А.
- Добавьте стрелку (↑↓), показывающую направление сортировки.
- Сортировка работает только по загруженным данным (без дополнительных запросов).

### Вариант 4. Посты с пагинацией
- Работайте с `https://jsonplaceholder.typicode.com/posts`.
- Отображайте по 10 постов за страницу (колонки: **ID**, **Title**, `Body` — до 30 символов).
- Добавьте кнопки «Назад» / «Вперед».
- Напишите тест: после клика «Вперед» отображаются посты с 11 по 20.

### Вариант 5. Кэширование в `localStorage`
- Перед загрузкой проверяйте `localStorage.getItem('usersCache')`.
- Если данные есть и моложе 1 минуты, используйте их.
- Иначе загружайте с API и сохраняйте с `timestamp`.
- При загрузке из кэша показывайте подсказку «Данные из кэша».
- Добавьте кнопку «Очистить кэш».

### Вариант 6. Поиск по email
- Добавьте `<input type="text">` над таблицей с плейсхолдером «Поиск по email».
- При вводе 3+ символов фильтруйте пользователей без дополнительных кнопок.
- Поиск регистронезависимый (`toLowerCase()`).
- Если нет результатов — выводите «Ничего не найдено».
- Напишите тест: ввод «ap» и проверка фильтрации.

### Вариант 7. Альбомы с количеством фото
- Загрузите альбомы с `https://jsonplaceholder.typicode.com/albums`.
- Для каждого альбома подгрузите фото `https://jsonplaceholder.typicode.com/photos?albumId=<ID>` и посчитайте количество.
- Используйте `Promise.all()` для параллельной загрузки.
- Показывайте «Загрузка...» до получения данных.
